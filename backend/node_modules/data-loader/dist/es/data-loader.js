var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable max-classes-per-file */
import lodashGet from "lodash-es/get";
// TODO: move that at a common place in the nightingale repo to be reused
// Watch out for the generated file structure when that is moved up in the repo
export class NightingaleElement {
}
const store = new Map();
export const load = (url, headers = new Headers({ accept: "application/json" })) => {
    const cached = store.get(url);
    if (cached)
        return cached;
    const promise = (() => __awaiter(void 0, void 0, void 0, function* () {
        const response = yield window.fetch(url, { headers });
        if (!response.ok) {
            throw new Error(`Request Failed: Status = ${response.status}; URI = ${url}; Time = ${new Date()}`);
        }
        if (response.status === 204) {
            // no data
            return { payload: null, headers: response.headers };
        }
        const payload = yield response.json();
        return { payload, headers: response.headers };
    }))();
    store.set(url, promise);
    promise.catch(() => store.delete(url));
    return promise;
};
const getSourceData = (children) => Array.from(children).filter(child => child.matches('source[src], script[type="application/json"]'));
class DataLoader extends HTMLElement {
    // Custom element reactions
    constructor() {
        super();
        this._data = null;
        this.selector =
            (this.getAttribute("selector") || "").trim() || ((d) => d);
    }
    static get is() {
        return "data-loader";
    }
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            // get all the potentials sources elements
            const sources = getSourceData(this.children);
            // if nothing there, bails
            if (!sources.length)
                return;
            const errors = [];
            let detail;
            // go over all the potential sources to try to load data from it
            /* eslint-disable no-restricted-syntax */
            for (const source of sources) {
                try {
                    if (source instanceof HTMLSourceElement) {
                        detail = Object.assign(Object.assign({}, (yield load(source.src))), { srcElement: source, src: source.src });
                    }
                    else {
                        detail = {
                            payload: JSON.parse(source.textContent)
                        };
                    }
                    // if we're here, we have data, go out of the loop
                    break;
                }
                catch (error) {
                    errors.push(error);
                }
            }
            if (!detail) {
                this._errors = errors;
                try {
                    this.dispatchEvent(new CustomEvent("error", {
                        detail: errors,
                        bubbles: true,
                        cancelable: true
                    }));
                }
                catch (e) {
                    console.error(e);
                }
                return;
            }
            // apply selector to retrieved data
            if (typeof this.selector === "string") {
                this._data = lodashGet(detail.payload, this.selector);
            }
            else {
                this._data = this.selector(detail.payload);
            }
            detail.payload = this.data;
            this.dispatchEvent(new CustomEvent("load", { detail, bubbles: true, cancelable: true }));
        });
    }
    // Getters/Setters
    // data
    get data() {
        return this._data;
    }
    // loaded
    get loaded() {
        return !!this.data;
    }
    // errors
    get errors() {
        return this._errors;
    }
    // loaded
    get selector() {
        return this._selector;
    }
    set selector(value) {
        this._selector = value;
    }
    connectedCallback() {
        this.fetch();
    }
}
export default DataLoader;
//# sourceMappingURL=data-loader.js.map